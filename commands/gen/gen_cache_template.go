package gen

const templateCacheCmdContent = `
// ==========================================================================
// This is auto-generated by gf cli tool. DO NOT EDIT THIS FILE MANUALLY.
// ==========================================================================
package codec

import (
	"banban/app/pb"
	"fmt"
	"banban/app/dao"
	
	"google.golang.org/protobuf/proto"
)

//Codec{TplName} {TplTable} 适配
type Codec{TplName} struct{}

// Pt 生成pb.Entity{TplName}数据
func (Codec{TplName}) Pt() proto.Message {
	return &pb.Entity{TplName}{}
}

// Key 生成缓存key
func (serv Codec{TplName}) Key(data proto.Message) string {
	pk := serv.Pk(data)
	if pk > 0 {
		return fmt.Sprintf("{TplPrefix}.%d", pk)
	}
	return ""
}

func (Codec{TplName}) Pk(data proto.Message) int64 {
	instance, ok := data.(*pb.Entity{TplName})
	if ok {
		return int64(instance.{TplStructPk})
	}
	return 0
}

func (Codec{TplName}) All() ([]proto.Message, error) {
	res, err := dao.{TplName}.All()
	if err != nil {
		return []proto.Message{}, err
	}
	data := make([]proto.Message, len(res));
	for i, item := range res {
		data[i] = item;
	}
	return data, nil
}

func init() {
	register("{TplTable}", &CacheDefault{
		codec: &Codec{TplName}{},
		ttl:   {TplTtl},
	})
}
`

const templateCacheProtoContent = `
syntax = "proto3";
package pb;

// ==========================================================================
// This is auto-generated by gf cli tool. DO NOT EDIT THIS FILE MANUALLY.
// ==========================================================================
/*
用户信息proto
*/


//表示目标文件生成的路径, go的包名就是最后的目录名
//目前统一生成到 app/pb 目录下
option go_package = "../app/pb";

import "entity_{TplTable}.proto";

message BaseCacheRepBatch{TplName} {
	repeated pb.Entity{TplName} data = 1;
}
`

const templateCacheClientContent = `
// ==========================================================================
// This is auto-generated by gf cli tool. DO NOT EDIT THIS FILE MANUALLY.
// ==========================================================================
package client

import (
	"banban/app/pb"
	"context"
)

//Get{TplName} 获取单个用户信息请求
//异常情况返回的error 不为 nil
//未查到信息时，返回对象也为 nil
//保持和php查询数据库相同的返回逻辑
func (serv *baseCache) Get{TplName}(ctx context.Context, key uint32, fields []string) (*pb.Entity{TplName}, error) {
	return serv.Get{TplName}Int64(ctx, int64(key), fields)
}

func (serv *baseCache) Get{TplName}Int64(ctx context.Context, key int64, fields []string) (*pb.Entity{TplName}, error) {
	req := &pb.BaseCacheReqSimple{
		Key:    key,
		Fields: fields,
	}
	reply := &pb.Entity{TplName}{}
	err := serv.call(ctx, "Get{TplName}", req, reply)
	if err != nil || reply.{TplStructPk} == 0 {
		return nil, err	
	}
	return reply, err
}

//Mget{TplName} 批量获取多个信息请求
//异常情况返回的error 不为 nil
//未查到信息时，返回对象也为空切片
//保持和php查询数据库相同的返回逻辑
func (serv *baseCache) Mget{TplName}(ctx context.Context, keys []uint32, fields []string) ([]*pb.Entity{TplName}, error) {
	keysInt64 := make([]int64, len(keys))
	for i, v := range keys {
		keysInt64[i] = int64(v)
	}
	return serv.Mget{TplName}Int64(ctx, keysInt64, fields)
}

func (serv *baseCache) MgetMap{TplName}(ctx context.Context, keys []uint32, fields []string) (map[uint32]*pb.Entity{TplName}, error) {
	keysInt64 := make([]int64, len(keys))
	for i, v := range keys {
		keysInt64[i] = int64(v)
	}
	res, err := serv.Mget{TplName}(ctx, keys, fields)
	data := make(map[uint32]*pb.Entity{TplName})
	if err == nil {
		for _, item := range res {
			data[uint32(item.{TplStructPk})] = item
		}
	}
	return data, err
}

func (serv *baseCache) Mget{TplName}Int64(ctx context.Context, keys []int64, fields []string) ([]*pb.Entity{TplName}, error) {
	req := &pb.BaseCacheReqBatch{
		Keys:   keys,
		Fields: fields,
	}
	reply := &pb.BaseCacheRepBatch{TplName}{}
	err := serv.call(ctx, "Mget{TplName}", req, reply)
	return reply.Data, err
}

func (serv *baseCache) MgetMap{TplName}Int64(ctx context.Context, keys []int64, fields []string) (map[int64]*pb.Entity{TplName}, error) {
	res, err := serv.Mget{TplName}Int64(ctx, keys, fields)
	data := make(map[int64]*pb.Entity{TplName})
	if err == nil {
		for _, item := range res {
			data[int64(item.{TplStructPk})] = item
		}
	}
	return data, err
}
`

const templateCachePluginContent = `
package internal

import (
	"google.golang.org/protobuf/proto"
)

// ProcessBefore{TplName} 
func (serv *cmdCache) ProcessBefore{TplName}(data proto.Message, op string, current, old map[string]string) (bool, error) {
	return false, nil
}

// ProcessAfter{TplName} 
func (serv *cmdCache) ProcessAfter{TplName}(data proto.Message, op string, current, old map[string]string) error {
	return nil
}
`

const templateCacheServerContent = `
// ==========================================================================
// This is auto-generated by gf cli tool. DO NOT EDIT THIS FILE MANUALLY.
// ==========================================================================
package cache

import (
	"banban/app/dao"
	"banban/app/pb"
	"banban/app/service/codec"
	"banban/library/go2cache"
	"banban/library/tool"
	"context"
	"database/sql"
	"fmt"

	"google.golang.org/protobuf/proto"
)

var server{TplName} *go2cache.Server

func init() {
	server{TplName} = go2cache.NewServer(ProfileCodec{TplName}{})
	if {TplTtl} > 0 {
		server{TplName}.SetTTL({TplTtl});
	}
	tool.Ref.Init(&pb.Entity{TplName}{})
}

// ProfileCodec{TplName} 定义用户 {TplTable} 接口实现
type ProfileCodec{TplName} struct {
}

// Pt 创建一个pb.Entity{TplName} 数据
func (ProfileCodec{TplName}) Pt() proto.Message {
	return &pb.Entity{TplName}{}
}

// Key 生成缓存key
func (ProfileCodec{TplName}) Key(key int64) string {
	if key == 0 {
		return ""
	}
	return fmt.Sprintf("{TplPrefix}.%d", key)
}

// Pk 根据proto数据，获取主键信息
func (ProfileCodec{TplName}) Pk(data proto.Message) int64 {
	if entity, ok := data.(*pb.Entity{TplName}); ok {
		return int64(entity.{TplStructPk})
	}
	return 0
}

// One 根据主键查询单个信息
func (ProfileCodec{TplName}) One(ctx context.Context, key int64, data proto.Message) error {
	err := dao.{TplName}.Ctx(ctx).Where("{TplPk} = ?", key).Struct(data)
	if err != nil && err != sql.ErrNoRows {
		return err
	}
	return nil
}

// FindAll 批量查询信息
func (ProfileCodec{TplName}) FindAll(ctx context.Context, keys []int64, callback go2cache.Find2Item) error {
	res, err := dao.{TplName}.Ctx(ctx).Where("{TplPk} in (?)", keys).FindAll()
	if err != nil {
		return err
	}
	for _, item := range res {
		callback(item)
	}
	return nil
}

//Get{TplName} 获取单个信息
func (serv *CacheServer) Get{TplName}(
	ctx context.Context,
	req *pb.BaseCacheReqSimple,
	reply *pb.Entity{TplName},
) error {
	var err error
	if cc, ok := serv.codecCfg["{TplTable}"]; ok {
		_, err = cc.Cache.Get(req.Key, reply)
	} else {
		err = serverXsGift.Get(ctx, req.Key, reply)
	}
	if err == nil {
		//复制数据
		tool.Ref.RetainFieldSlice(reply, req.Fields)
	}
	return err
}

//Mget{TplName} 获取多个信息
func (serv *CacheServer) Mget{TplName}(
	ctx context.Context,
	req *pb.BaseCacheReqBatch,
	reply *pb.BaseCacheRepBatch{TplName},
) error {
	fields := tool.Ref.SliceToMap(req.Fields)
	if cc, ok := serv.codecCfg["{TplTable}"]; ok {
		return cc.Cache.Mget(req.Keys, func(item proto.Message) {
			target, ok := item.(*pb.Entity{TplName})
			if ok {
				tool.Ref.RetainFieldMap(target, fields)
				reply.Data = append(reply.Data, target)
			}
		})
	} else {
		return serverXsGift.Mget(ctx, req.Keys, func(item proto.Message) {
			target, ok := item.(*pb.Entity{TplName})
			if ok {
				tool.Ref.RetainFieldMap(target, fields)
				reply.Data = append(reply.Data, target)
			}
		})
	}
}

//Query{TplName} 根据索引批量查询
func (serv *CacheServer) Query{TplName}(
	ctx context.Context,
	req *pb.BaseCacheReqQuery,
	reply *pb.BaseCacheRepBatch{TplName},
) error {
	fields := tool.Ref.SliceToMap(req.Fields)
	limit := req.Limit
	if limit == 0 {
		limit = 20
	}	
	if cc, ok := serv.codecCfg["{TplTable}"]; ok {
		if len(req.Args) == 0 {
			return fmt.Errorf("table {TplTable}, empty args")
		}
		args := make([]codec.QueryArgs, len(req.Args))
		for i, item := range req.Args {
			args[i] = codec.QueryArgs{
				Key: item.Key,
				Val: item.Val,
			}
		}
		cc.Cache.Query(func(item proto.Message) {
			target, ok := item.(*pb.Entity{TplName})
			if ok {
				tool.Ref.RetainFieldMap(target, fields)
				reply.Data = append(reply.Data, target)
			}
		}, req.Desc, limit, args...)
		return nil
	}else{
		return fmt.Errorf("table {TplTable} is not supported")	
	}
}
`
